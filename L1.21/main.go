package main

import "fmt"

type OldLogger struct {
}

func (targ *OldLogger) SaveInfo(m string) {
	fmt.Println("Метод логирования старого логгера")
}

type LoggerAdapter struct {
	logger *OldLogger
}

func NewLoggerAdapter(logger *OldLogger) *LoggerAdapter {
	return &LoggerAdapter{logger: logger}
}

func (targ *LoggerAdapter) Log(m string) {
	targ.logger.SaveInfo(m)
}

type Logger interface {
	Log(m string)
}

func main() {
	var oldLog OldLogger
	adapter := NewLoggerAdapter(&oldLog)
	adapter.Log("...")
}

/*
Адаптеры полезный паттерн, который позволяет подружить
объекты, которые были не совместимы. Это как некая обертка над нашим классом,
чтобы он смог работать с нужными нам методами.

В примере показано, как мы имеем новый логгер в проекте, но мы также
не хотим отказываться от страго логера, и
чтобы его можно было испольщовать как и новый логгер,
создается адаптер, который является оберткой над нашим старым логером,
с методом Log, который присущ только новым логерам. В методе Log адаптера,
можно прописать новую логику или просто как в примере вызвать старую функцию,
которая по сути делает тоже самое, что и функция Log у нового логгера, просто
имеет другой нейминг.

Также так как адаптер является оберткой, то мы не как не изменяем тот класс,
который хотим подружить с другим или другим методом, что очень полезно, так
как меняя структуру старого класса можно что то сломать если он использовался
где-то в другом месте.

И как итог можно добавить что интерфейс Logger задает некий паттерн поведения,
а адаптер позволяет соответствовать этому поведению, тем частям кода про которые
новый код ничего не знает.

*/
